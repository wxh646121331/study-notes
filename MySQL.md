# 1. MySQL的架构介绍

## 1.1 MySQL简介

- mysql内核
- sql优化工程师
- mysql服务器的优化
- 各种参数常量设定
- 查询语句优化
- 主从复制
- 软硬件升级
- 容灾备份
- sql编程

## 1.2 MySql安装

- 下载地址：

- 查看安装时创建的mysql用户和mysql组

  > cat /etc/passwd | grep mysql
  >
  > cat /etc/group | grep mysql
  >
  > mysqladmin --version

- 启、停mysql服务端

  > service mysql start
  >
  > service mysql stop
  >
  > service mysql restart


## 1.3 MySql配置文件

> cp /usr/share/mysql/my-default.cnf /etc/my.cnf

## 1.4 MySQL逻辑架构介绍

## 1.5 MySQL存储引擎

# 2. 索引优化分析

## 2.1 性能下降SQL慢

## 2.2 常见通用的join查询

## 2.3 索引简介

## 2.4 性能分析

## 2.5 索引优化

# 3. 查询截取分析

## 3.1 查询优化

## 3.2 慢查询日志

## 3.3 批量数据脚本

## 3.4 Show Profile

## 3.5 全局查询日志

# 4. MySQL锁机制

## 4.1 表锁

## 4.2 行锁

## 4.3 页锁

# 5. 主从复制

## 5.1 复制的基本原则

## 5.2 复制的最大问题

## 5.3 一主一从常见配置



# 极客时间MySQL实战

# 1 一条sql查询语句是如何执行的

## 1.1 MySQL的逻辑架构

![](./images/MySQL/MYSQL逻辑架构图.png)

- MySQL可以大体分为server层和引擎层两部分
  - server层：server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如：存储过程、触发器、视图等。
  - 引擎层：存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。InnoDB从MySQL 5.5.5版本开始成为了默认存储引擎。

## 1.2 连接器

- 连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令：

  ```mysql
  mysql -h$ip -P$port -u$root -p
  ```

- 查看连接状态：

  ```mysql
  show processlist;
  ```

- 客户端如果太长时间没动静，连接器会自动将它断开。这个时间是由wait_timout控制的，默认值是8小时

- 长连接与短连接：

  - 长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接
  - 短连接则是每次执行完很少的几次查询就断开连接，下次查询再重新建立一个
  - 建立连接的过程比较复杂，建议尽量使用长连接
  - 全部使用长连接后，MySQL占用内存可能涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候才释放。
    - 解决方案：
      1. 定期断开长连接
      2. MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重新连接和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

## 1.3 查询缓存

- 执行过的查询语句及结果可以会以key-value的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。

- 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上的所有的查询缓存都会被清空。所有更新压力大的数据库，查询缓存的命中率会非常低。而表态表则适合使用查询缓存

- “按需使用”查询缓存，可以将query_cache_type设置成DEMAND，这样对于默认的sql语句都不使用查询缓存，而对于你确定要使用缓存的语句，可以用SQL_CACEH显示指定

  ```mysql
  select SQL_CACHE * from T where ID=10;
  ```

- 注意：MySQL 8.0版本直接将查询缓存的整块功能删掉了

## 1.4 分析器

- 词法分析：SQL语句由多个字符串和空格组成，MySQL需要识别出里面的字符串分别是什么，代表什么
  - MySQL从“select”这个关键字识别出来，这是一个查询语句
  - 把字符串“T”识别成“表象T”
  - 把字符串“ID”识别成“列ID”
- 语法分析：根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法

## 1.5 优化器

- 在表里有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关键（join）的时候，决定各个表的连接顺序

## 1.6 执行器

- 开始执行的时候，要先判断一下是否有对表T的查询权限
- 如果有权限，就打开表继续执行，打开表的时候，执行器会根据表的引擎定义，去使用引擎提供的接口。如果：表T中，ID字段没有索引，执行器的执行流程是：
  - 调用InnoDB引擎接口取这个表的和一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中； 
  - 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行； 
  - 执行器将上述遍历过程中所有满足条件的行组成的记录集任务结果集返回给客户端。
- 数据库的慢查询日志中有一个rows_examined字段，表示这个语句执行过程中扫描了多少行，这个值就是在执行器每次调用引擎获取数据行的时候累加的
- 有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行跟跟rows_examined并不是完全相同的

# 2 日志系统：一条SQL更新语句是如何执行的？

~~~mysql
create table T(ID int primary key, c int);
insert into T values (1, 1);
insert into T values (2, 1);
update T set c=c+1 where ID=2;
~~~

## 2.1 redo log

- 问题：在MySQL里，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高

- 解决方案：WAL（Write-Ahead Logging）技术，它的关键点就是先写日志，再写磁盘

- 具体细节：当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做的

- InnoDB的redo log是固定大小的，比如可以配置成一组4个文件，每个文件的大小是1GB，总共可以记录4GB的操作，从头开始写，写到末尾就又回到开头循环写

  ![](./images/MySQL/redo log写日志.png)

  - write pos：当前记录的位置，一边写一边后移，写到3号文件末尾后就回到0号文件开头
  - check point：当前要擦除的位置，也是往后推移并且循环的，擦除记录之前要把记录更新到数据文件
  - write pos和check point之间是还空着的部分，可以用来记录新的操作，如果write pos追上check point，表示redo log满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把check point推进一下
  - crash-safe：有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe

## 2.2 binlog

- binlog是server层的日志系统，binlog只能用来归档
- redo log与binlog的区别
  1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用
  2. redo log 是物理日志，记录的是“在某个数据页上做了什么修改“；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如”给 ID=2 这一行的c字段加1“
  3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的，”追加写“是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志

## 2.3 更新语句执行流程图

![](./images/MySQL/更新语句执行流程图.png)

## 2.4 两阶段提交

- 如果不使用两阶段提交，在恢复临时库场景或者扩容的场景，可能会出现数据不一致的情况

## 2.5 思考题

- 定期全量备份的周期”取决于系统重要性，有的是一天一备，有的是一周一备“。那么在什么场景下，一天一备会比一周一备更有优势？它影响了这个数据库系统的哪个指标？
  - 好处是”一天一备“比”一周一备“的”最长恢复时间“更短，”一天一备“模式里，最坏情况只需要应用一天的binlog，而”一周一备“模式里，最坏情况下可能要应用一周的binlog
  - 系统的对应指标是RTO（恢复目标时间）
  - 当然，频繁备份是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个RTO是成本换来的，这就需要根据业务重要性来评估了

# 3 事务隔离：为什么你改了我还看不见？

## 3.1 隔离性与隔离级别

- 多个事务同步执行时，可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些总是，就有了”隔离级别“的概念
- SQL事务隔离级别：
  - 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到
  - 读提交：一个事务提交之后，它做的变更才会被其他事务看到
  - 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的
  - 串行化：”写“会加”写锁“，”读“会加”读锁“，当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

## 3.2 事务隔离的实现

- 在可重复读隔离级别下，每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值
- 多版本并发控制（MVCC）：同一条记录在系统中可以存在多个版本
- 当系统里没有比这个回滚日志更早的read-view的时候，回滚日志就会被删除
- 尽量不要使用长事务，其中一个原因是因为：长事务意味着系统里面会存在很老的事务视图，由于这些事务随时可能访问数据库里的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间

## 3.3 事务的启动方式

- 显式启动事务语句，begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback

- set autocommit=0，这个命令会将这个线程的自动提交关掉，意味着如果你只执行select语句，这个事务就启动了，而且不会自动提交，这个事务持续存在直到你主动执行commit或rollback语句，或者断开连接

- 提交事务并自动启动下一个事务，commit work and chain

- 查询长事务：在information_schema库的innodb-trx这个表中，如查找持续时间超过60s的事务：

  ```mysql
  select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60;
  ```

## 3.4 思考题

- 系统里应该避免长事务，如果你是业务开发负责人同时也是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢？

# 4 深入浅出索引（上）

## 4.1 索引的常见模型

- 哈希表
  - 适用于只有等值查询的场景，比如Memcached及其它一些NoSQL引擎
  - 因为哈希表不是有序的，所以哈希索引做区间查询的速度是很慢的
- 有序数组
  - 在等值查询和范围查询场景中的性能都非常优秀
  - 但是有序数据在插入一个新记录的时候就必须得挪动后面所有的记录，成本太高
  - 有序数组索引只适用于表态存储引擎
- 二叉搜索树
  - 二叉搜索树的读写效率都比较高，但是由于索引还要写在磁盘上，为了让一个查询尽量少地读磁盘，数据库索引一般会采用N叉树
- 跳表、LSM树等

## 4.2 InnoDB的索引模型

- 在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表
- InnoDB使用了B+树索引模型，数据都是存储在B+树中的，每一个索引在InnoDB里面对应一棵B+树
- 索引类型：
  - 主键索引也被称为聚簇索引（clustered index）
    - 主键索引的叶子节点存的是整行数据
  - 非主键索引也被称为二级索引（secondary index）
    - 非主键索引的叶子节点存的是主键的值
  - 基于主键索引和普通索引的查询区别
    - 主键查询方式，只需要搜索主键B+树
    - 普通索引查询方案，则需要先搜索普通索引树，得到主键的值，再到主键索引树上搜索一次，这个过程称为回表
    - 基于非主键索引的查询需要多扫描一棵索引对，因此，我们应该尽量使用主键查询

## 4.3 索引维护

- 页分裂：如果新插入的记录所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为页分裂
  - 页分裂会影响性能，同时还会影响数据页利用率
- 页合并：当相邻两个数据页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程
- 自增主键：是指自增列上定义的主键，在建表语句中一般是这样定义的：NOT NULL PRIMARY KEY AUTO_INCREMENT
  - 性能方面，自增主键的插入数据模式，正符合的递增插入的场景，每次插入一条新记录，都是追回操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂
  - 从存储空间方面考量，自动主键为整型，占用4个字节或8个字节（bigint），主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小
- 适合用业务字段直接做主键的场景（KV场景）
  - 只有一个索引
  - 该索引必须是唯一索引

## 4.4 思考题

- 对于以下InnoDB表T，

  ~~~mysql
  create table T(
    id int primary key, 
    k int not null, 
    name varchar(16), 
    index(k))engine=InnoDB;
  ~~~

  如果你要重建索引k，你的SQL语句可以这么写：

  ~~~mysql
  alter table T drop index k;
  alter table T add index(k);
  ~~~

  如果你要重建主键索引，也可以这么写：

  ~~~mysql
  alter table T drop primary key;
  alter table T add primary key(id);
  ~~~

  对于上面这两个重建索引的做法，如果有不合适的，为什么？更好的方法是什么？

  - 答案：重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，可以用这个语句代替：alter table T engine=InnoDB。

# 附录

## 常用命令

| 命令                              | 说明                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| mysql -h\$ip -P\$port -u\$user -p | 连接数据库                                                   |
| show processlist;                 | 查看连接状态，等价于select * from information_schema.processlist; |
| show databases;                   | 查询所有schema                                               |
| use database_name;                | 切换scheme                                                   |
| use tables;                       | 查询当前数据库下所有的表                                     |
| desc table_name;                  | 查看表结构                                                   |
| show variables like '%tx%';       | 查看参数配置                                                 |
| show full columns from tableN;    | 查看表结构详细                                               |

## 常用参数

| 参数                           | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| innodb_flush_log_at_trx_commit | 设置成 1 的时候表示每次事务的 redo log 都直接持久化到磁盘，建议设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失 |
| sync_binlog                    | 设置成1表示每次事务的 binlog 都持久化到磁盘，建议设置成 1，可以保证 MySQL 异常重启之后 binlog 不丢失 |
|                                |                                                              |

## 常用函数

| 函数                          | 说明           |
| ----------------------------- | -------------- |
| str_to_date(date, '%Y-%m-%d') | 字段串转Date   |
| date_format(date, '%Y-%m-%d') | Date转字符串   |
| timediff(date1, date2)        | 取时间差       |
| time_to_sec(datediff)         | 将时间差转成秒 |

## 时间格式

| 格式 | 说明                              |
| ---- | --------------------------------- |
| %Y   | 4位的年份                         |
| %y   | 2位的年份                         |
| %m   | 月，格式为01…...12                |
| %c   | 月，格式为1……12                   |
| %d   | 月份中的天数，格式为00……31        |
| %e   | 月份中的天数，格式为0……31         |
| %H   | 小时，格式为00……23                |
| %k   | 小时，格式为0……23                 |
| %h   | 小时，格式为01……12                |
| %l   | 小时，格式为1……12                 |
| %i   | 分，格式为00……59                  |
| %r   | 时间，格式为12小时hh:mm:ss [A/P]M |
| %T   | 时间，格式为24小时hh:mm:ss        |
| %S   | 秒，格式为00……59                  |
| %s   | 秒                                |

